## Lesson: ArrayLists (Dynamic Arrays)
#### Learning Objectives
- Understand what an **ArrayList** is and how it differs from a fixed array
- Learn how to **declare**, **initialize**, and **manipulate** an ArrayList
- Understand **Generics** (`<T>`) in Java
- Practice using **ArrayList methods** like `add`, `get`, `set`, and `remove`
- Start reading **Java documentation** for classes


In Java, a **fixed array** is efficient but limited, it has a **set size** that can’t be changed.

The **ArrayList** class (from `java.util`) is different:

- **Dynamic size**: You can **add** and **remove** elements anytime.
- **Still sequential**: Uses **zero-based indexing** like arrays.
- **More built-in methods**: Makes adding, searching, and removing easier.

Example:

```java
import java.util.ArrayList;

ArrayList<Integer> myArray = new ArrayList<Integer>();
myArray.add(10);
myArray.add(11);
System.out.println(myArray); // [10, 11]
```

#### Sample Illustration – Comparing Fixed Array vs ArrayList

```
Fixed Array: [10, 11, 0, 0, 0]  <-- Fixed length, unused slots
ArrayList:   [10, 11]           <-- Grows and shrinks as needed
```

#### Generics (`<T>`)

When creating an ArrayList, you must specify **the type of objects** it will store.

Example:

```java
ArrayList<String> names = new ArrayList<String>(); // Only Strings allowed
ArrayList<Integer> numbers = new ArrayList<Integer>(); // Only Integers allowed
```

Why?
Generics:
- Prevent type errors (you can’t accidentally add a `String` to an Integer list)
- Help the compiler allocate memory properly
- Make your code safer and easier to debug

**Generics as Type Safety**

```
ArrayList<Integer>:  [10, 20, 30]  ✅
ArrayList<Integer>:  [10, "Hello"] ❌ Error
```

#### Object Types Only

ArrayLists store **objects**, not primitives.
That’s why we use **wrapper classes**:

* `int` → `Integer`
* `double` → `Double`
* `char` → `Character`

Strings are already objects, so no change is needed.

#### Manipulating ArrayLists

ArrayLists don’t use bracket indexing for setting/getting values. Instead, use **methods**:

```java
import java.util.ArrayList;

ArrayList<Integer> myArray = new ArrayList<Integer>();

// Add elements
myArray.add(10); // [10]
myArray.add(11); // [10, 11]

// Get element
Integer num = myArray.get(0); // 10

// Set element
myArray.set(0, 9); // [9, 11]

// Remove element
myArray.remove(1); // [9]

// Size of ArrayList
System.out.println(myArray.size()); // 1
```
**Adding and Removing**

```
Start:       []
add(10) →    [10]
add(11) →    [10, 11]
remove(0) →  [11]
```

#### Mixed-Type ArrayList

If you really want to store **different object types**:

```java
ArrayList<Object> things = new ArrayList<Object>();
things.add(10);             // Integer
things.add("Hello");        // String
things.add(12.5);           // Double

System.out.println(things); // [10, Hello, 12.5]
```

However — using mixed types can be messy and harder to maintain.

#### Practice Exercise

```java
import java.util.ArrayList;

public class ArrayListsPractice {
    public static void main(String[] args) {
        String[] words = {"it", "is", "this", "we", "do", "how"};
        ArrayList<String> phrase = new ArrayList<String>();

        // TODO:
        // 1. Rearrange words into: [this, is, how, we, do, it]
        // 2. Print the phrase
        // Expected: [this, is, how, we, do, it]
        
        System.out.println(phrase);
    }
}
```


#### Key Takeaways
- **ArrayLists** are resizable — unlike fixed arrays.
- Use **Generics** (`<T>`) to specify the type stored.
- Can only store **objects** (use wrapper classes for primitives).
- Use methods like `.add()`, `.get()`, `.set()`, `.remove()`, `.size()`.
- Still **zero-based indexed** like arrays.

#### Useful Links
- [Java ArrayList Documentation](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)
- [Java Generics](https://docs.oracle.com/javase/tutorial/java/generics/)
- [Wrapper Classes in Java](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html)
