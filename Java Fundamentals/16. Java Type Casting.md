## Lesson: Java Type Casting**
### Learning Objectives
- Understand what **type casting** is in Java and why it’s needed
- Learn the difference between **explicit** and **implicit** casting
- Know when to use **primitive** vs **object** types for better performance
- Understand the possible pitfalls when converting between types

#### Introduction

Java is a **statically typed language** meaning once you declare a variable’s type, it cannot change at runtime. However, Java allows **type casting**, which is converting a variable from one type to another.

Type casting gives flexibility, but you must be aware of **memory sizes and value ranges** to avoid losing data or causing errors.


**Primitive Data Types and Their Ranges**

| Type    | Size in Bytes | Range                                                   |
| ------- | ------------- | ------------------------------------------------------- |
| byte    | 1 byte        | -128 to 127                                             |
| short   | 2 bytes       | -32,768 to 32,767                                       |
| int     | 4 bytes       | -2,147,483,648 to 2,147,483,647                         |
| long    | 8 bytes       | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
| float   | 4 bytes       | approx ±3.40282347E+38F                                 |
| double  | 8 bytes       | approx ±1.79769313486231570E+308                        |
| char    | 2 bytes       | 0 to 65,536                                             |
| boolean | n/a           | `true` or `false`                                       |

When **casting down** *(converting from a larger range to a smaller range)*, you risk **data loss**.

#### Explicit Casting

**Explicit casting** is when you manually specify the type you want to convert to.

Example:

```java
class CastingExample {
    public static void main(String[] args) {
        double d = 35.25;
        double dd = 35.99;
        
        // Explicitly casting double to int
        int i = (int) d;
        int ii = (int) dd;
        
        System.out.println(i);   // 35
        System.out.println(ii);  // 35
    }
}
```

Even though `dd` is **35.99**, casting to `int` truncates the decimal part — no rounding happens.


#### Implicit Casting

**Implicit casting** (also called **widening conversion**) happens automatically when Java converts a smaller type into a larger type that can hold the value without loss.

Example:

```java
class CastingExample {
    public static void main(String[] args) {
        int i = 35;
        float f = i; // Automatically casts int → float
        System.out.println("The number is: " + f);
    }
}
```

Output:

```
The number is: 35.0
```

Java automatically converted `int` to `float`, and also converted the `float` to a `String` when concatenated in `System.out.println()`.



#### Primitive vs Object Types

In Java, there are two categories of types:

* **Primitive types**: store only data (e.g., `int`, `double`, `boolean`)
* **Object types**: instances of classes that store data **and** methods (e.g., `Integer`, `Double`, `Boolean`)


#### Performance Difference

Using object types can be **slower** because they require creating an object in memory.

Example — slow version:

```java
public class TestSum {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        
        Integer sum = 0; // Object type
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i; // Creates a new Integer object each time
        }
        
        System.out.println("Sum: " + sum);
        long end = System.currentTimeMillis();
        
        double total = (double) (end - start) / 1000;
        System.out.println("Execution time: " + total + " seconds");
    }
}
```

On a typical system:

```
Sum: 1073741825
Execution time: ~6.4 seconds
```

---

Example — faster version:

```java
public class TestSum {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        
        int sum = 0; // Primitive type
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i;
        }
        
        System.out.println("Sum: " + sum);
        long end = System.currentTimeMillis();
        
        double total = (double) (end - start) / 1000;
        System.out.println("Execution time: " + total + " seconds");
    }
}
```

Output:

```
Sum: 1073741825
Execution time: ~0.76 seconds
```

Big difference — primitive types are faster for heavy computation.


#### Null Values

* **Primitive types** cannot be `null`.
* **Object types** can be `null` because they are references.

Example:

```java
public class TestNull {
    public static void main(String[] args) {
        Integer a = 10; // Object type
        int b = 10;     // Primitive type
        
        a = null; // Valid
        b = null; // Compile error: incompatible types
    }
}
```

#### Key Takeaways

* Use **explicit casting** when converting from larger to smaller range types.
* Use **implicit casting** when converting from smaller to larger range types.
* Prefer **primitive types** for performance-critical code.
* Use **object types** when you need `null` values or when working with Java Collections.

#### Useful Links

* [Java Variables Documentation](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)
* [Java Type Conversion Documentation](https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html)

