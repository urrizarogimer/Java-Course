## Modularization in Java

#### Learning Objectives

By the end of this lesson, you will be able to:
- Understand the purpose of modularizing code in Java
- Import and use Java classes across multiple files
- Use a test class to access and verify code from other classes using object instances

### Why Modularize?

Modularization means breaking down your code into smaller, reusable partsâ€”each part handling a specific responsibility. This approach improves:

* Code organization
* Reusability across different programs
* Maintainability and testability

In Java, we achieve modularization by placing related methods in their own classes, then accessing those classes from a main or test file.


### The Main Method

Only one file in a Java program typically contains the `main` method, which acts as the **entry point** of the application. This file is used to start the program and test functionality from other modules.

```java
public class AwesomeAppStarter {
    public static void main(String[] args) {
        // code to run app or test other classes
    }
}
```

All other classes (modules) can be accessed from this file using **importing** or **dependency injection**.


### Importing External Classes

Java provides many built-in classes (like `Date`) that can be imported using an import statement. You can also organize your own code into separate files and import them when needed.

**Example:**

**`Greetings.java`**

```java
import java.util.Date;

class Greetings {
    public String getCurrentDate() {
        Date date = new Date();
        return "Current date is: " + date;
    }

    public String greetEnglish(String name) {
        return "Hello, " + name;
    }

    public String greetSpanish(String name) {
        return "Hola, " + name;
    }
}
```

### Dependency Injection

Instead of calling static methods directly, we often create **object instances** of a class. This practice is known as **dependency injection**, and it allows access to all public methods of a class.

**Example:**

**`TestGreetings.java`**

```java
public class TestGreetings {
    public static void main(String[] args) {
        Greetings greeterApp = new Greetings(); // create instance
        String dateMessage = greeterApp.getCurrentDate(); // call method
        System.out.println(dateMessage); // display output
    }
}
```

This approach is commonly used to separate functionality (defined in one class) and the running logic (handled by a test or main class).


### Test File Structure

The **Greetings** class defines the logic (methods), while the **TestGreetings** class runs or tests it. This separation of concerns makes your code modular and reusable.

**TestGreetings.java**

```java
public class TestGreetings {
    public static void main(String[] args) {
        Greetings greeterApp = new Greetings();
        String dateMessage = greeterApp.getCurrentDate();
        System.out.println(dateMessage);
    }
}
```

As long as `Greetings.java` and `TestGreetings.java` are in the same directory, Java will compile both when you compile the test file:

```sh
javac TestGreetings.java
java TestGreetings
```

### Practice Exercise

Try this out by creating a new class that stores and retrieves capital cities and their countries.

**Test.java**

```java
public class Test {
    public static void main(String[] args){
        Capitals capitalApp = new Capitals();

        capitalApp.getCapital("Brazil");
        System.out.println(capitalApp.getCountry("Vienna"));

        capitalApp.getCapital("Croatia");
        System.out.println(capitalApp.getCountry("Abu Dhabi"));
    }
}
```

**Capitals.java**

```java
public class Capitals {
    public void getCapital(String country){
        System.out.println("What is the capital of " + country + "?");
        switch(country){
            case "Austria":
                System.out.println("The capital of " + country + " is Vienna.");
                break;
            case "Brazil":
                System.out.println("The capital of " + country + " is Brasilia.");
                break;
            case "Cyprus":
                System.out.println("The capital of " + country + " is Nicosia.");
                break;
            case "Egypt":
                System.out.println("The capital of " + country + " is Cairo.");
                break;
            case "Ghana":
                System.out.println("The capital of " + country + " is Accra.");
                break;
            default:
                System.out.println("I don't know the capital of " + country + ".");
        }
    }

    public String getCountry(String capital){
        System.out.println(capital + " is the capital of which country?");
        switch(capital){
            case "Vienna":
                return capital + " is the capital of Austria.";
            case "Brasilia":
                return capital + " is the capital of Brazil.";
            case "Nicosia":
                return capital + " is the capital of Cyprus.";
            case "Cairo":
                return capital + " is the capital of Egypt.";
            case "Accra":
                return capital + " is the capital of Ghana.";
            default:
                return "I don't know that city.";
        }
    }
}
```

#### Expected Output:

```
What is the capital of Brazil?
The capital of Brazil is Brasilia.
Vienna is the capital of which country?
Vienna is the capital of Austria.
What is the capital of Croatia?
I don't know the capital of Croatia.
Abu Dhabi is the capital of which country?
I don't know that city.
```

### Summary

* Modularization involves separating logic into distinct classes to make code reusable, organized, and maintainable.
* The `main` method acts as the entry point of the program and is used to test or run other classes.
* Java supports importing both built-in classes (like `Date`) and user-defined classes.
* **Dependency injection** allows access to a class's methods by creating an instance of the class.
* Keeping logic and execution separate (as in `Greetings` vs `TestGreetings`) is a best practice.
* You can compile and run multi-file Java programs by compiling only the test file, as long as all files are in the same directory.

---

Let me know if you'd like a student worksheet or quiz version of this lesson, or the next topic such as Java packages, static methods, or access modifiers.
